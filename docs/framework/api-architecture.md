# API architecture


The term 'API' refers to that code stored in the top level api folder.
It's important to note that only compliant code & usage will be
supported. Usage documentation is in the [API
v3](/api/index.md) page.

## Standards {:#standards}

-   The ONLY supported way to interact with any code in the API folder
    from outside the api folder is by using the `civicrm_api()` wrapper
-   Functionality delivered by the API is only supported if it is
    1.  Advertised via the 'getfields function' OR (preferably AND)
    2.  Verified by a test
-   Where functions sit on the api but don't conform to the api
    standards they may be supported by the creators but not by the
    api team.

## Individual functions

-   All functions MUST have a success test as a minimum (failure tests
    are only required for special features). API functions without tests
    are not supported & are, in fact, not considered to be part of
    the API.
-   There are a number of (fairly new) helper functions you should use
    in the test - please check [Writing a PHPUnit testcase
    HOWTO](testing/setup.md)
-   API functions should match the relevant BAO names & have the
    functions 'get', 'create' and delete'
-   All functions should receive $params as an array(not a reference)
-   All functions should return either
    -   an id indexed array of results via
        the `civicrm_api3_create_success()` function
    -   an appropriate message via throw new api_Exception
-   (REVIEW this in light of feedback from bgm that it is not optimal
    for translation) Do not use `ts()` in error messages (this will be
    added in the exception function if you use api_Exception - but you
    need to add a code)
-   If a BAO object exists this must be passed to the `create_success` or
    `create_error` function for freeing

-   All setting of defaults, enforcement of required fields, management
    of field aliases & field validation should be done at the wrapper
    layer using the getfields function results
-   Dates will be formatted to ISO format at the api layer, individual
    functions should assume this (api layer uses `strtotime()`)
-   API functions should be accompanied by a `_spec` function to declare
    fields & specifications for fields not retrieved from the
    `$dao->fields` function or with different specifications to
    those returned.
-   All API functions should have a code comment block per standard
    below
-   As little functionality as possible should be in the API
    functions themselves. Single line api functions should be the rule
    not the exception. Where possible they should look like the
    following basic functions:

    ```php
    function civicrm_api3_survey_create($params) {
      return _civicrm_api3_basic_create(_civicrm_api3_get_BAO(__FUNCTION__), $params);
    }
    ```
    
    ```php
      function civicrm_api3_survey_get($params) {
        return _civicrm_api3_basic_get(_civicrm_api3_get_BAO(__FUNCTION__), $params);
      }
    ```
    
    ```php
    function civicrm_api3_survey_delete($params) {
      return _civicrm_api3_basic_delete(_civicrm_api3_get_BAO(__FUNCTION__), $params);
    }
    ```
    
## Code comment blocks {:#docblock}

-   API comment blocks shall include a description of the action & the
    input and output params - per the example
-   API comment blocks shall include references to test generated
    examples (these are generated by adding
    `$this->documentMe($params,$result,__FUNCTION__,__FILE__);`
    to tests

    ```php
    /**
     * Create or update a survey
     *
     * @param array $params 
     *   Associative array of property name/value pairs to insert in new 'survey'.
     * @example SurveyCreate.php Std Create example
     * @return array api result array
     * {@getfields survey_create}
     * @access public
     */
    ```
    
## `_spec` functions {:#spec}

A "`_spec` function" must exist for every API entity/action pair.

For example is is the [source](https://github.com/civicrm/civicrm-core/blob/1f4ea7262d865c72e8946481fdbfe18f5159da9e/api/v3/Tag.php#L62) of the `_spec` function for the `tag` entity, with the `create` action:

```php
function _civicrm_api3_tag_create_spec(&$params) {
  $params['used_for']['api.default'] = 'civicrm_contact';
  $params['name']['api.required'] = 1;
  $params['id']['api.aliases'] = array('tag');
}
```

If the `_spec` function makes no alterations to `$params`, then each field will behave as defined in the [schema definition](framework/schema-definition/#table-field) for the entity. All of those field-level xml schema tags are also available for use in the API `_spec` function. So for example, you can use `$params['id']['type'] = CRM_Utils_Type::T_INT;` to specify that the `'id'` field must be an integer.
  

Additionally, the following settings may be applied to each field: 

| Key | Description |
| -- | -- |
| `'api.aliases'` | An array of strings which represent alternate names by which this field may be referenced |
| `'api.default'` | Specifies a default value for the field |
| `'api.filter'` | ??? |
| `'api.required'` | Set this to `1` to indicate that the field is required |
| `'api.return'` | ??? |
| `'api.unique'` | ??? |
| `'description'` | A human-readable description of the field which will be displayed in the [API explorer](/api/index.md#api-explorer) |
| `'options'` | Used to specify an array of values which are considered valid for the field |
| `'supports_joins'` | ??? |
| `'FKApiName` | ??? |
| `'FKClassName'` | Allows the wrapper layer to return useful information if the constraint causes the call to fail. Should be a class name as a string. |
| `'FKKeyColumn'` | ??? |

## How to migrate or write an api

-   **Look at existing apis** in the civicrm/api/v3 directory
    as examples.  Start with a simple API like the survey api as the
    basis for your new api.\
    \
-   **Use _spec functions** to declare any fields or features\
    \
-   **Name the API, API functions, php file, and php functions. **\
    -   **There is a simple relationship among the names of all of these
        elements** and if you name your php files and functions
        correctly and place them in the civicrm/api/v3 directory, the
        API and function will automatically appear and work.  If you
        have created the files and functions but they do not appear in
        API explorer, it is most likely because of a mis-match in your
        naming conventions.
    -   **Example:** The API civicrm_api(ExampleEntity,Action) is going
        to look for the function civicrm_api3_example_entity_action
        in civicrm/api/v3/ExampleEntity/Action.php  OR
        civicrm/api/v3/ExampleEntity.php (the latter is the
        most common).
    -   **Note the change of case and use of underline characters** in
        filenames vs function names.  In filenames, an upper case letter
        denotes the start of a word, whereas in function names, all
        words are lower case and words are separated with underscores.
         To make matters more confusing, case of API names is important
        but case of the action name ('Action' in the example above)
        is (sometimes) ignored.
    -   **More examples:**\
        -   PHP call: civicrm_api('LineItem','create')
        -   Ajax call:
            /civicrm/ajax/rest?json=1&sequential=1&debug=1&&entity=LineItem&action=create
        -   PHP file: civicrm/api/v3/LineItem.php
        -   Function line (within
            civicrm/api/v3/LineItem.php): function civicrm_api3_line_item_create($params)
            { . . .\
            \
        -   PHP call: civicrm_api('Job','cleanup')
        -   Ajax
            call: /civicrm/ajax/rest?json=1&sequential=1&debug=1&&entity=Job&action=cleanup
        -   PHP file: civicrm/api/v3/Job.php
        -   Function line (within civicrm/api/v3/Job.php): function
            civicrm_api3_job_cleanup( $params ) { . . . \

-   **Generally you will want to place any custom api/v3 files within
    your [custom php
    directory](http://wiki.civicrm.org/confluence/display/CRMDOC41/Directories), under {yourcustomcivicrmphpdirectory}/api/v3.** Files
    placed there will behave just as though placed in civicrm/api/v3.
    This prevents your customized files from being deleted or
    overwritten when you upgrade CiviCRM.
    -   However, as of 4.2.2 there is a problem with this:  The API
        Explorer and (more importantly) the Scheduled Job page at
        Administer/System Settings/Scheduled Jobs, do not recognize API
        files created and stored in the custom php directory. So you can
        create the APIs in your customPHP directory, you can execute and
        run them without problems (for instance, go to
        URL <http://mywebsite.com/civicrm/ajax/rest?json=1&sequential=1&debug=1&entity=Myapi&action=get> and
        it works fine) but the API and functions don't show in the API
        explorer or the Scheduled Jobs page.  This is a serious
         disadvantage because a common use of API just is to run them as
        scheduled jobs.
    -   For now, the way around that problem is to create your API in
        the custom php directory and then create a symbolic link
        civicrm/api/v3 with the same name that points to the API file in
        the custom php directory.  For example:
        -   API file is here:
            */home/mysite/www/sites/default/files/civicrm/customphp/api/v3/Myapi.php*
        -   You need symbolic
            link */home/mysite/www/sites/all/modules/civicrm/api/v3/Myapi.php*
            pointing to the API file.
        -   Create that symbolic link with a Unix command like this:\
            -   ln
                -s /home/mysite/www/sites/default/files/civicrm/customphp/api/v3/Myapi.php /home/mysite/www/sites/all/modules/civicrm/api/v3/Myapi.php\

-   **Note that some actions (eg. getfields) are generic** and don't
    need to be re-defined.\

-   **Write a test. **\
    \
-   **Write your comment blocks**\
    \
-   **Make sure you comply** to [API Architecture
    Standards](/confluence/display/CRMDOC/API+Architecture+Standards)
